{"name":"ied","tagline":"Like npm, but faster - an alternative package manager for Node","body":"ied\r\n===\r\n\r\n[![Travis](https://img.shields.io/travis/alexanderGugel/ied.svg)](https://travis-ci.org/alexanderGugel/ied)\r\n[![npm](https://img.shields.io/npm/v/ied.svg)](https://www.npmjs.com/package/ied)\r\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg)](http://standardjs.com/)\r\n[![Join the chat at https://gitter.im/migme/beachball](https://img.shields.io/badge/gitter-join%20chat-brightgreen.svg)](https://gitter.im/alexanderGugel/ied)\r\n\r\nAn alternative package manager for Node.\r\n\r\n* **Concurrent Installations** - `ied` installs sub-dependencies in parallel.\r\n  This means that the download of a dependency might have been completed before\r\n  that of its parent or any of its siblings even started.\r\n\r\n* **Correct Caching** - Downloaded packages are being cached locally. Similarly\r\n  to the entry dependencies stored in `node_modules`, they are being identified\r\n  by their checksums. Therefore we can guarantee the consistency of the cache\r\n  itself without (manually) invalidating dependencies (e.g. due to overridden\r\n  version numbers).\r\n\r\n* **`node_modules` as CAS** - Packages are always being referenced by their\r\n  *SHA-1* checksums. Therefore a `node_modules` directory can be considered to\r\n  be a [Content Addressable\r\n  Storage](https://en.wikipedia.org/wiki/Content-addressable_storage), meaning\r\n  that packages are being identified by their contents, not by arbitrary\r\n  identifiers, such as package names that are not guaranteed to be unique\r\n  across different registries.\r\n\r\n* **Flat `node_modules`** - Due to the *CAS*-based design, conflicts due to\r\n  naming collisions are more or less impossible. Therefore all dependencies can\r\n  be stored in a flat directory structure. Circular dependencies and\r\n  dependencies on different versions of the same packages are still being\r\n  handled correctly.\r\n\r\n* **Guaranteed uniqueness** - Since the directory in which a specific package\r\n  is being stored is determined by its *shasum*, identical packages can't\r\n  conflict due to their location in the file system itself. This also means\r\n  that the same dependency won't be installed more than once. Dependencies\r\n  don't need to be explicitly declared as `peerDependencies`, since shared\r\n  sub-dependencies are the default, not an option.\r\n\r\n* **Atomic installs** - The atomicity of installs can be ensured on a\r\n  *package-level*. \"In progress\" downloads are being stored in\r\n  `node_modules/.tmp` and moved into `node_modules` once their download has\r\n  been completed. In order to prevent deadlocks, packages that have circular\r\n  dependencies are exempt from this limitation. In most cases however, the\r\n  `node_modules` directory is *consistent* at any given point in time during\r\n  the main installation procedure.\r\n\r\n* **Package names as links** - While packages are being referenced by their\r\n  *shasum* internally, they can still be required via their human-readable\r\n  equivalent name. Package names themselves are simply symbolic links to the\r\n  actual content-addressed package itself. A nice side-effect of this design is\r\n  that in contrast to other package managers, you can not accidentally require\r\n  a sub-dependency that hasn't been installed as such.\r\n\r\n* **Semantic Versioning** - [Semantic version numbers](http://semver.org/) are\r\n  being resolved correctly.\r\n\r\n* **Arbitrary package groups** - Packages can be grouped into \"package groups\",\r\n  such as `dependencies` and `devDependencies`. Dependencies can be installed\r\n  exclusively based on the group they are in.\r\n\r\n\r\nInternals\r\n---------\r\n\r\nUnder the hood, `ied` maintains an \"object database\", similar to `git`. Instead\r\nof storing packages by some arbitrary name, a SHA1-checksum is being generated\r\nto approximate their contents. The checksums can not only be used for\r\nguaranteeing a certain level of trust and consistency, but they also simplify\r\nthe algorithm through which dependencies are being managed.\r\n\r\nThe algorithm through which packages are being installed guarantees consistency\r\nthrough atomic installs. The installation of a package either fails or\r\nsucceeds, but at no point in time can a dependency itself be required without\r\nhaving its own sub-dependencies installed (with the exception of shared\r\ncircular dependencies).\r\n\r\nThe checksum of a package is based on the contents of the package itself, not\r\nof its sub-dependencies. Therefore the validity of a package can be verified by\r\nhashing the package itself. Subsequent dependency updates have no effect of the\r\ngenerated checksum.\r\n\r\nSince `node_modules` is essentially a file-system based content addressable\r\nstorage, multiple versions of the same package can co-exist in the same\r\nproject. In order to expose dependencies via CommonJS, symbolic links are being\r\ncreated that reference a specific version of the package. This has multiple\r\nadvantages:\r\n\r\n1. Undeclared dependencies that have been installed as sub-dependencies of\r\n   \"direct\" dependencies are unlikely to be required \"accidentally\".\r\n\r\n2. There is no need to \"manually\" (as in additionally to the installation\r\n   procedure itself) de-duplicate the dependency graph. As long as the\r\n   uniqueness of filenames itself can be guaranteed on an OS-level, it is\r\n   *impossible* to install the same package twice. This does not prevent users\r\n   from installing different versions of the same dependency as long as the\r\n   content is different (whereas a different version declared in the\r\n   `package.json` counts as different contents).\r\n\r\n3. Shorter pathnames and less problems due to OS-level limitations (as in\r\n   Windows where the maximum path length is limited).\r\n\r\n4. Additional application-level startup performance improvements. `require`\r\n   needs to traverse less directories. A limited number of symbolic links need\r\n   to be followed. This performance improvement is primarily useful for\r\n   continuously running tests, where startup time is actually noticeable for\r\n   larger test suits.\r\n\r\n\r\n### Directory Structure\r\n\r\nThe used directory structure is primarily optimized for reducing the amount of\r\nIO interaction with the file system during subsequent installations and\r\nguaranteeing the consistency of installed packages.\r\n\r\nA consequence of the\r\n[`require.resolve`](https://nodejs.org/api/modules.html#modules_all_together)\r\nalgorithm used by Node, all packages need to be stored in a project-level\r\n`node_modules` directory. This directory is completely flat on a package-level,\r\nmeaning that there are no nested packages inside it.\r\n\r\nInstead each package is being stored in its content-addressed directory. Such a\r\ndirectory has two sub-directories:\r\n\r\n* **package** - This is where the unpacked package contents is being stored. At\r\n  no point in time will this directory be modified. This enables us to verify\r\n  the integrity of the package at a later point in time by comparing the actual\r\n  checksum to the one defined by other dependents or registries.\r\n\r\n* **node_modules** - Sub-dependencies of the dependency installed in `package`\r\n  are being referenced by symbolic links in `node_modules` of the package\r\n  itself. `require.resolve` will fall-back to this level after failing to\r\n  locate a dependency in `package`. This means checked in dependencies are\r\n  still supported, provided that their sub-dependencies are also available\r\n  (anywhere in the dependency graph).\r\n\r\nOn a project level, the `node_modules` directory contains the fetched packages,\r\ninstalled dependencies and links that expose the packages to user-land via\r\n`require`.\r\n\r\nA comparison of sample directory structures produced by ied, npm 2 and npm 3 is\r\navailable as a [GitHub\r\nGist](https://gist.github.com/alexanderGugel/a10ed5655d366875a280).\r\n\r\n\r\nWhy?\r\n----\r\n\r\nThe original idea was to implement npm's pre-v3 install algorithm in as few\r\nlines as possible. This goal was achieved in\r\n[`c4ba56f`](https://github.com/alexanderGugel/ied/tree/c4ba56f7dece738db5b8cb28c20c7f6aa1e64d1d).\r\n\r\nCurrently the main goal of this project is to provide a more performant\r\nalternative to npm.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nThe easiest way to install ied is using [npm](https://www.npmjs.org/):\r\n\r\n```\r\n  npm i -g ied\r\n```\r\n\r\nAlternatively you can also \"bootstrap\" ied.\r\nAfter an initial installation via npm, ied will install its own dependencies:\r\n\r\n```\r\n  git clone https://github.com/alexanderGugel/ied ied && cd $_ && make install\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nThe goal of `ied` is to support ~ 80 per cent of the npm commands that one uses\r\non a daily basis. Feature parity with npm **other than** with its installation\r\nprocess itself is not an immediate goal. Raw performance is the primary concern\r\nduring the development process.\r\n\r\nA global [configuration](lib/config.js) can be supplied via environment\r\nvariables. `NODE_DEBUG` can be used in order to debug specific sub-systems. The\r\nprogress bar will be disabled in that case.\r\n\r\nAlthough `run-script` is supported, lifecycle scripts are not.\r\n\r\nAt this point in time, the majority of the command API is\r\n[self-documenting](bin/cmd.js). More extensive documentation will be available\r\nonce the API is stabilized.\r\n\r\nA high-level [USAGE](bin/USAGE.txt) help is also supplied. The main goal is to\r\nkeep the API predictable for regular npm-users. This means certain flags, such\r\nas for example `--save`, `--save-dev`, `--only`, are supported.\r\n\r\n```\r\n  ied is a package manager for Node.\r\n\r\n  Usage:\r\n\r\n    ied command [arguments]\r\n\r\n  The commands are:\r\n\r\n    install     fetch packages and dependencies\r\n    run         run a package.json script\r\n    test        run the test-suite of the current package\r\n    shell       enter a sub-shell with augmented PATH\r\n    ping        check if the registry is up\r\n    ls          print the dependency graph\r\n    expose      make a sub-dependency `require`able\r\n    config      print the used config\r\n    init        initialize a new package\r\n    link        link the current package or into it\r\n    unlink      unlink the current package or from it\r\n\r\n  Flags:\r\n    -h, --help      show usage information\r\n    -v, --version   print the current version\r\n    -S, --save      update package.json dependencies\r\n    -D, --save-dev  update package.json devDependencies\r\n    -o, --only      install a subset of the dependencies\r\n    -r, --registry  use a custom registry (default: http://registry.npmjs.org/)\r\n\r\n  Example:\r\n    ied install\r\n    ied install <pkg>\r\n    ied install <pkg>@<version>\r\n    ied install <pkg>@<version range>\r\n\r\n    Can specify one or more: ied install semver@^5.0.1 tape\r\n    If no argument is supplied, installs dependencies from package.json.\r\n    Sub-commands can also be called via their shorthand aliases.\r\n\r\n  README:  https://github.com/alexanderGugel/ied\r\n  ISSUES:  https://github.com/alexanderGugel/ied/issues\r\n```\r\n\r\nCredits\r\n-------\r\n\r\nSome ideas and (upcoming) features of `ied` are heavily inspired by\r\n[**Nix**](http://nixos.org/nix/), a purely functional package manager.\r\n\r\nFAQ\r\n---\r\n\r\n* What does ied stand for?\r\n\r\n  Nothing in particular. It's just easy to type and `mpm` (the original name)\r\n  was already taken.\r\n\r\nLicense\r\n-------\r\n\r\nLicensed under the MIT license. See [LICENSE](LICENSE.md).\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}